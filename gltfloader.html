<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>
        GLTF
    </title>
    <style>
        body {
            font-family: monospace;
        }
    </style>
</head>

<body>
    <input type="file" id="input-file" accept=".gltf" />
    <br><br>
    <div id="output">
        <p></p>
    </div>
    <script>

        /*
            GLTF loader.
        */


        const MAX_ELEMENT_PRINT = 200;

        const MODE_UPLOAD = 1;
        const MODE_FETCH = 2;
        const mode = MODE_UPLOAD;

        const fetch_uri = "DragonAttenuation/glTF/";
        const fetch_filename = "DragonAttenuation";
        const fetch_ext = ".gltf";


        const $ = (e) => document.querySelector(e);
        const $$ = (e) => document.querySelectorAll(e);

        function output(s = "") {
            var txt = $("#output p").innerHTML;
            txt += s + "<br>";
            $("#output p").innerHTML = txt;
        }

        function clearOutput() {
            var txt = $("#output p").innerHTML;
            $("#output p").innerHTML = "";
        }

        // https://github.com/KhronosGroup/glTF-Tutorials/blob/master/gltfTutorial/gltfTutorial_002_BasicGltfStructure.md

        // constants
        // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#accessor-data-types
        const bufferTypeComponent = { 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
        const sizeofType = { SCALAR: 1, VEC2: 2, VEC3: 3 };

        function printNumbers(buf, offs, size, groupnum, format) {
            let view = new format(buf, offs, size * groupnum);
            let dump = "";
            let count = 0;
            for (const number of view) {
                if (count % groupnum == 0)
                    dump += "<br>";
                dump += number.toString() + " ";
                count++;

                if (count > MAX_ELEMENT_PRINT * groupnum) {
                    dump += "<br>[...]<br>(max elements displayed)<br>[...]<br>";
                    break;
                }
            }

            output(dump);
        }

        async function printBuffer(gltf, accessorId, name) {
            const bufferViewId = gltf.accessors[accessorId].bufferView;
            let uri = gltf.buffers[gltf.bufferViews[bufferViewId].buffer].uri;

            if (mode == MODE_FETCH) {
                uri = fetch_uri + uri;
            }

            try {
                let res = await fetch(uri);
                let data = await res.blob();
                let reader = new FileReader();
                reader.readAsArrayBuffer(data);

                reader.onload = function () {
                    let buf = reader.result;

                    output();
                    output();
                    output("(" + name + ")");

                    printNumbers(
                        buf,
                        gltf.bufferViews[bufferViewId].byteOffset,
                        gltf.accessors[accessorId].count,
                        sizeofType[gltf.accessors[accessorId].type],
                        bufferTypeComponent[gltf.accessors[accessorId].componentType]
                    );
                }
            } catch (err) {
                output();
                output("--ERROR--");
                output(err);
                throw err;
            }

        }

        function buildTrsMatrix(node) {
            let trs = ["trs_identity"];
            if (node.translation) {
                trs.push(node.translation);
            }
            if (node.rotation) {
                trs.push(node.rotation);
            }
            if (node.scale) {
                trs.push(node.scale);
            }

            return trs;
        }

        function printScenegraph(gltf, nodeId, prefix = "", modelMat = ["identity"]) {

            let trsMat = buildTrsMatrix(gltf.nodes[nodeId]);
            modelMat.push(trsMat);

            output(prefix + " " + gltf.nodes[nodeId].name + " :: modelMat = " + modelMat);
            if (gltf.nodes[nodeId].children) {
                gltf.nodes[nodeId].children.forEach(child => printScenegraph(gltf, child, prefix + "+", modelMat));
            }
        }

        function printMesh(gltf, nodeId) {

            const node = gltf.nodes[nodeId];
            output(node.name);

            if (node.mesh != null) {
                const mesh = gltf.meshes[node.mesh];
                output(mesh.name);
                mesh.primitives.forEach(async primitive => {
                    await printBuffer(gltf, primitive.attributes.POSITION, "position");
                    await printBuffer(gltf, primitive.attributes.NORMAL, "normal");
                    await printBuffer(gltf, primitive.attributes.TEXCOORD_0, "uv");
                    await printBuffer(gltf, primitive.indices, "face");
                });
            } else {
                output("no mesh.");
            }

            if (node.children) {
                node.children.forEach(child => printMesh(gltf, child));
            }
        }

        function dumpGLTF(gltf) {
            output();
            output("scenegraph");
            output("----------");
            output();
            gltf.scenes.forEach(scene => {
                scene.nodes.forEach(node => {
                    printScenegraph(gltf, node);
                });
            });

            output();
            output("meshes");
            output("------");
            output();
            gltf.scenes.forEach(scene => {
                scene.nodes.forEach(node => {
                    printMesh(gltf, node);
                });
            });

        }

        function dumpFile(filename, filecontent) {
            let jsoncontent = JSON.parse(filecontent);
            if (jsoncontent === null) {
                throw "Can't parse json.";
            }

            dumpGLTF(jsoncontent);
        }

        function processFile(file) {
            let reader = new FileReader();

            clearOutput();

            reader.onload = function (e) {
                output("(" + file.name + " loaded)");
                dumpFile(file.name, e.target.result);
            }

            reader.onerror = function (e) {
                output("Can't load " + file.name);
            }

            reader.readAsText(file);
        }

        function init() {
            let fileInput = $("#input-file");

            if (mode == MODE_UPLOAD) {
                fileInput.addEventListener("change", function () {
                    processFile(this.files[0]);
                }, false);
            } else {
                fileInput.setAttribute("disabled", "");
                // for multi-part files gltf (with .bin), so you wont get kicked out from CORS
                fetch(fetch_uri + fetch_filename + fetch_ext).then(response => response.json()).then(gltf => {
                    dumpGLTF(gltf);
                }).catch(e => console.log(e));
            }
        }


        init();

    </script>
</body>

</html>